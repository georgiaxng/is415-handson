{
  "hash": "e7bcfa6216ad26c586a15d870ecd6637",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take Home Exercise 3\"\nauthor: \"Georgia Ng\"\ndate: \"October 17, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n  cache: true\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Click to view the code\"\n    embed-resources: true\n---\n\n\n# 1. Overview\n\n## 1.1 Introduction\n\n## 1.2 My Responsibilities\n\n-   Data Preparation, Preprocessing\n\n## 1.3 Importing Packages\n\nHere, we have loaded the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse, RColorBrewer, ggplot2, spatstat, jsonlite, units, matrixStats, httr)\n```\n:::\n\n\n# 2. The Data\n\nFor this project, we will be using the following data sets.\n\n-   Singapore Rental Flat Prices (Jan-17 to Sep-24) from data.gov.sg\n\n-   Master Plan 2014 Subzone Boundary (Web) from data.gov.sg\n\n-   Hawker Centres Dataset from [data.gov.sg](https://data.gov.sg/datasets?formats=GEOJSON%7CKML%7CSHP%7CKMZ&sort=relevancy&page=1&resultId=d_4a086da0a5553be1d89383cd90d07ecd)\n\n-   Kindergarten, Childcare Datasets from [OneMap API](https://www.onemap.gov.sg/apidocs/)\n\n-   Bus Stops Location, MRT/ LRT Locations from [LTA Data Mall](https://datamall.lta.gov.sg/content/datamall/en/search_datasets.html?searchText=bus%20stop)\n\n-   Shopping Mall Coordinates through wikipedia and webscraping with the coordinates retrieved through OneMap API\n\n## 2.1 Importing Geospatial Data\n\n### 2.1.1 Importing Singapore Subzone Boundaries\n\nThe code chunk below is used to import *MP_SUBZONE_WEB_PL* shapefile by using `st_read()` of **sf**packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_read(dsn = \"data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP/\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(mpsz_sf, 'data/rds/mpsz_sf.rds')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n```\n\n\n:::\n:::\n\n\n#### 2.1.1.1 Checking Validity of Geometries\n\nUsing st_is_valid, we can check to see whether all the polygons are valid or not. From the results, we can see a total of 9 not valid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# checks for the number of geometries that are invalid\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\nTo rectify this, we can use `st_make_valid()` to correct these invalid geometries as demonstrated in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_make_valid(mpsz_sf)\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nHere is a plot of Singapore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpsz_sf)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### 2.1.2 Importing Kindergartens\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nkindergarten_json <- fromJSON(\"data/geospatial/kindergartens.json\")\n\nkindergarten_cleaned <- kindergarten_json$SrchResults[-1, ]\n\nkindergarten_df <- data.frame(\n  NAME = kindergarten_cleaned$NAME,\n  latitude = sapply(kindergarten_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[1])),\n  longitude = sapply(kindergarten_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[2]))\n)\n\nkindergarten_sf <- kindergarten_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(kindergarten_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 19307.62 ymin: 38859.25 xmax: 30705.05 ymax: 46300.26\nProjected CRS: SVY21 / Singapore TM\n                                                        NAME\n1 PCF Sparkletots Preschool @ Cheng San-Seletar Blk 435 (KN)\n2 PCF Sparkletots Preschool @ Cheng San-Seletar Blk 533 (KN)\n3 PCF Sparkletots Preschool @ Cheng San-Seletar Blk 556 (DS)\n4        PCF Sparkletots Preschool @ Chong Pang Blk 107 (KN)\n5        PCF Sparkletots Preschool @ Chong Pang Blk 122 (KN)\n6      PCF Sparkletots Preschool @ Chua Chu Kang Blk 10 (KN)\n                   geometry\n1 POINT (30325.45 38859.25)\n2 POINT (30190.51 39574.18)\n3  POINT (30705.05 39337.9)\n4 POINT (27354.73 45992.92)\n5 POINT (27755.87 46300.26)\n6 POINT (19307.62 40271.08)\n```\n\n\n:::\n:::\n\n\n### 2.1.3 Importing Childcare\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nchildcare_json <- fromJSON(\"data/geospatial/childcare.json\")\n\nchildcare_cleaned <- childcare_json$SrchResults[-1, ]\n\nchildcare_df <- data.frame(\n  NAME = childcare_cleaned$NAME,\n  latitude = sapply(childcare_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[1])),\n  longitude = sapply(childcare_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[2]))\n)\n\nchildcare_sf <- childcare_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(childcare_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 17828.84 ymin: 29221.89 xmax: 40985.94 ymax: 45530.47\nProjected CRS: SVY21 / Singapore TM\n                                            NAME                  geometry\n1 APOLLO INTERNATIONAL PRESCHOOL PRIVATE LIMITED POINT (40985.94 33848.38)\n2                   APPLE TREE PLAYHOUSE PTE LTD POINT (28308.65 45530.47)\n3 Appleland Montessori Child Care Centre Pte Ltd POINT (17828.84 36607.36)\n4                            APPLELAND PLAYHOUSE POINT (25579.73 29221.89)\n5             APRICOT ACADEMY (LAGUNA) PTE. LTD. POINT (38981.02 32483.41)\n6                                Arise Preschool    POINT (21588.47 36307)\n```\n\n\n:::\n:::\n\n\n### 2.1.4 Importing Hawker Centre\n\nSimilarly here, we will use `st_read` to read the geojson information, however since the columns values are in the format of \\`\\<th\\></th>\\` etc we will need to use a regex which is what we have done below to extract the name of the hawker centres.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nhawker_sf <- st_read('data/geospatial/HawkerCentresGEOJSON.geojson')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `HawkerCentresGEOJSON' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/HawkerCentresGEOJSON.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 125 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6974 ymin: 1.272716 xmax: 103.9882 ymax: 1.449017\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\n# Function to extract name from description\nextract_name <- function(description) {\n  if (!is.na(description)) {\n    # Use regular expression to extract the NAME \n    name <- sub(\".*<th>NAME</th> <td>(.*?)</td>.*\", \"\\\\1\", description)\n    if (name == description) {\n      return(NA)  # Return NA if no match is found\n    }\n    return(name)\n  } else {\n    return(NA) \n  }\n}\n\n# Apply the extraction function to every row\nhawker_sf <- hawker_sf %>%\n  mutate(Name = sapply(Description, extract_name)) %>% select (-Description)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hawker_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.7798 ymin: 1.284425 xmax: 103.9048 ymax: 1.449017\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n                             Name                      geometry\n1     Market Street Hawker Centre POINT Z (103.8502 1.284425 0)\n2    Marsiling Mall Hawker Centre POINT Z (103.7798 1.433539 0)\n3    Margaret Drive Hawker Centre POINT Z (103.8047 1.297486 0)\n4 Fernvale Hawker Centre & Market POINT Z (103.8771 1.391592 0)\n5       One Punggol Hawker Centre  POINT Z (103.9048 1.40819 0)\n6    Bukit Canberra Hawker Centre POINT Z (103.8225 1.449017 0)\n```\n\n\n:::\n:::\n\n\nAs shown above, we can see that the geographic coordinate system for the hawker dataset is in WGS84 and has XYZ coordinates, among which contains the Z-coordinates we do not need. Thus, we can use `st_zm()` to remove the Z-coordinate and project it to the SVY21 coordiate system using `st_transform()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhawker_sf <- st_zm(hawker_sf) %>%\n  st_transform(crs = 3414)\n\nhead(hawker_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 22042.51 ymin: 29650.7 xmax: 35955.52 ymax: 47850.43\nProjected CRS: SVY21 / Singapore TM\n                             Name                  geometry\n1     Market Street Hawker Centre  POINT (29874.82 29650.7)\n2    Marsiling Mall Hawker Centre POINT (22042.51 46139.03)\n3    Margaret Drive Hawker Centre  POINT (24816.7 31094.91)\n4 Fernvale Hawker Centre & Market  POINT (32867.9 41500.77)\n5       One Punggol Hawker Centre POINT (35955.52 43336.13)\n6    Bukit Canberra Hawker Centre POINT (26794.39 47850.43)\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntmap_mode('plot')\ntm_shape(mpsz_sf) +\n  tm_polygons()+\n  tm_shape(hawker_sf) +\n  tm_dots(col='red')\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n### 2.1.5 Importing Bus Stops\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbusstop_sf <- st_read(dsn = \"data/geospatial/BusStopLocation_Jul2024/\", layer = \"BusStop\")%>%\n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `BusStop' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/BusStopLocation_Jul2024' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5166 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48285.52 ymax: 52983.82\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(busstop_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 20134.2 ymin: 31253.63 xmax: 35565.66 ymax: 41659.52\nProjected CRS: SVY21 / Singapore TM\n  BUS_STOP_N BUS_ROOF_N            LOC_DESC                  geometry\n1      65059        B12        ST ANNE'S CH POINT (35565.66 41659.52)\n2      16171        B06     YUSOF ISHAK HSE POINT (21439.91 31253.63)\n3      61101        NIL             BLK 120 POINT (31381.06 35313.49)\n4      01239        B01        SULTAN PLAZA POINT (31152.55 31688.08)\n5      17269        B01             BLK 730  POINT (20134.2 31917.38)\n6      11291        B17 COLD STORAGE JELITA POINT (22723.57 33349.85)\n```\n\n\n:::\n:::\n\n\n### 2.1.6 Importing Shopping Malls\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshoppingmall_sf <- read_csv('data/geospatial/shopping_mall_coordinates.csv') %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(shoppingmall_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 28561.14 ymin: 28563.01 xmax: 31449.41 ymax: 34203.18\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 2\n  `Mall Name`                               geometry\n  <chr>                                  <POINT [m]>\n1 100 AM                         (29129.86 28563.01)\n2 313@Somerset                   (28561.14 31485.08)\n3 Aperia                         (31449.41 32531.06)\n4 Balestier Hill Shopping Centre (29029.77 34203.18)\n5 Bugis Cube                     (30483.66 31167.35)\n6 Bugis Junction                 (30458.71 31274.83)\n```\n\n\n:::\n:::\n\n\n### 2.1.7 Importing MRT\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmrt_sf <- st_read(dsn = \"data/geospatial/TrainStation_Jul2024/\", layer = \"RapidTransitSystemStation\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `RapidTransitSystemStation' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/TrainStation_Jul2024' \n  using driver `ESRI Shapefile'\nSimple feature collection with 230 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 6068.209 ymin: 27478.44 xmax: 45377.5 ymax: 47913.58\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\nHaving imported the dataset, we will now need to check for both invalid geometries and NA values before proceeding. The chunk of code detects not only these but also resolves it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check for invalid geometries and NA values\nvalidity_checks <- st_is_valid(mrt_sf, reason = TRUE)\n\n# Identify indices with NA\nna_indices <- which(is.na(validity_checks))\n\n# Filter out rows with NA values from the mrt object\nmrt_sf <- mrt_sf[-na_indices, ]\n\n# Verify the mrt object no longer contains invalid geometries\nany(is.na(sf::st_is_valid(mrt_sf)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nHere we use `st_transform()` to convert it to the SVY21 Coordinates System of CRS code 3414.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmrt_sf <- mrt_sf %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf)+\n  tm_polygons() +\n  tm_shape(mrt_sf) +\n  tm_dots(col='red')\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n### 2.1.8 Importing Primary School\n\nThis chunk of code imports the primary school dataset from data.gov.sg and uses the `select()` function to select the relevant columns through the input of the column numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprimarysch_df = read_csv('data/geospatial/Generalinformationofschools.csv') %>% filter(mainlevel_code =='PRIMARY') %>% select(1,3,4)\n```\n:::\n\n\n#### 2.1.8.1 Geocoding Primary School Data using OneMap API\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ngeocode <- function(address, postal) {\n  base_url <- \"https://www.onemap.gov.sg/api/common/elastic/search\"\n  query <- list(\"searchVal\" = address,\n                \"postal\" = postal,\n                \"returnGeom\" = \"Y\",\n                \"getAddrDetails\" = \"N\",\n                \"pageNum\" = \"1\")\n  \n  res <- GET(base_url, query = query)\n  restext<-content(res, as=\"text\")\n  \n  output <- fromJSON(restext)  %>% \n    as.data.frame %>%\n    select(results.LATITUDE, results.LONGITUDE)\n\n  return(output)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nprimarysch_df$LATITUDE <- 0\nprimarysch_df$LONGITUDE <- 0\n\nfor (i in 1:nrow(primarysch_df)){\n  temp_output <- geocode(primarysch_df[i, 2], primarysch_df[i, 3])\n  print(i)\n  \n  primarysch_df$LATITUDE[i] <- temp_output$results.LATITUDE\n  primarysch_df$LONGITUDE[i] <- temp_output$results.LONGITUDE\n}\nwrite_rds(primarysch_df, 'data/rds/geocoded_primarysch.rds')\n```\n:::\n\n\nAs shown below, using `head()` we can see that the new columns for lat and long has been added with the values fetched using the OneMap API.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(primarysch_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  school_name                  address                      postal_code\n  <chr>                        <chr>                              <dbl>\n1 ADMIRALTY PRIMARY SCHOOL     11   WOODLANDS CIRCLE             738907\n2 AHMAD IBRAHIM PRIMARY SCHOOL 10   YISHUN STREET 11             768643\n3 AI TONG SCHOOL               100  Bright Hill Drive            579646\n4 ALEXANDRA PRIMARY SCHOOL     2A   Prince Charles Crescent      159016\n5 ANCHOR GREEN PRIMARY SCHOOL  31   Anchorvale Drive             544969\n6 ANDERSON PRIMARY SCHOOL      19   ANG MO KIO AVE 9             569785\n```\n\n\n:::\n:::\n\n\nUsing `read_rds`, we can access the already processed and geocoded data from rds without needing to run through the geocoding function again. Since the data is in the WGS coordinate system, we can use `st_transform()` to project it to the `SVY21` coordinate system we will be using.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprimarysch_df <- read_rds('data/rds/geocoded_primarysch.rds')\nprimarysch_sf <- primarysch_df %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntmap_mode('plot')\ntm_shape(mpsz_sf)+\n  tm_polygons() +\n  tm_shape(primarysch_sf) +\n  tm_dots(col='red')\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n## 2.2 Importing Aspatial Data\n\n### 2.2.1 Importing Rental Flat\n\nThe code chunk below is used to import the rental\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df = read_csv('data/aspatial/RentingOutofFlats2024CSV.csv')\n```\n:::\n\n\nTo get a brief overview of existing columns of this dataset, we can use `colnames()` to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(rental_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rent_approval_date\" \"town\"               \"block\"             \n[4] \"street_name\"        \"flat_type\"          \"monthly_rent\"      \n```\n\n\n:::\n:::\n\n\n#### 2.2.1.1 Converting `rent_approval_date` to a Valid Date Format\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df$rent_approval_date <- ym(rental_df$rent_approval_date)\n```\n:::\n\n\n#### 2.2.1.2 Filtering For Selected Time Frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df <- rental_df %>%\n  filter(year(rent_approval_date) == 2024)\n```\n:::\n\n\n#### 2.2.1.3 Geocoding Rental Flat Data Using OneMap API\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeocode <- function(block, streetname) {\n  base_url <- \"https://www.onemap.gov.sg/api/common/elastic/search\"\n  address <- paste(block, streetname, sep = \" \")\n  query <- list(\"searchVal\" = address, \n                \"returnGeom\" = \"Y\",\n                \"getAddrDetails\" = \"N\",\n                \"pageNum\" = \"1\")\n  \n  res <- GET(base_url, query = query)\n  restext<-content(res, as=\"text\")\n  \n  output <- fromJSON(restext)  %>% \n    as.data.frame %>%\n    select(results.LATITUDE, results.LONGITUDE)\n\n  return(output)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df$LATITUDE <- 0\nrental_df$LONGITUDE <- 0\n\nfor (i in 1:nrow(rental_df)){\n  temp_output <- geocode(rental_df[i, 3], rental_df[i, 4])\n  print(i)\n  \n  rental_df$LATITUDE[i] <- temp_output$results.LATITUDE\n  rental_df$LONGITUDE[i] <- temp_output$results.LONGITUDE\n}\nwrite_rds(rental_df, 'data/rds/geocoded_rental_2024.rds')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df <- read_rds('data/rds/geocoded_rental_2024.rds')\n```\n:::\n\n\n#### 2.2.1.4 CRS Adjustments\n\nAnother important step after importing the dataset is checking the coordinate system used, as seen in the result below using `st_crs()`, we can see that there is no CRS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(rental_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System: NA\n```\n\n\n:::\n:::\n\n\nTherefore, we need to convert the longitude and latitude columns into a spatial format. Since our dataset is based in Singapore and it uses the SVY21 coordinate reference system (CRS Code: 3414), we will use the `st_transform()` function to perform the conversion and create the geometry column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- rental_df %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\nUsing `st_crs()`, we can check and verify that the conversion is successful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 15786.61 ymin: 30769.77 xmax: 39668.39 ymax: 45634.94\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 7\n  rent_approval_date town            block street_name    flat_type monthly_rent\n  <date>             <chr>           <chr> <chr>          <chr>            <dbl>\n1 2024-01-01         YISHUN          386   YISHUN RING RD 4-ROOM            3700\n2 2024-01-01         JURONG WEST     140B  CORPORATION DR 4-ROOM            3900\n3 2024-01-01         SENGKANG        471B  FERNVALE ST    5-ROOM            3700\n4 2024-01-01         KALLANG/WHAMPOA 10    GLOUCESTER RD  3-ROOM            3600\n5 2024-01-01         BEDOK           31    BEDOK STH AVE… 5-ROOM            4350\n6 2024-01-01         QUEENSTOWN      82    STRATHMORE AVE 4-ROOM            3000\n# ℹ 1 more variable: geometry <POINT [m]>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf) +\n  tm_polygons()+\n  tm_shape(rental_sf) +\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n#### 2.2.1.5 Checking for NA values\n\nThis chunk of code checks the dataset for any na values in all of the columns. As shown below, there is none.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf %>%\n  summarise(across(everything(), ~ sum(is.na(.)))) -> extra_NA \nextra_NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 6 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 11519.15 ymin: 28097.64 xmax: 45192.3 ymax: 48741.06\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 1 × 7\n  rent_approval_date  town block street_name flat_type monthly_rent\n               <int> <int> <int>       <int>     <int>        <int>\n1                  0     0     0           0         0            0\n# ℹ 1 more variable: geometry <MULTIPOINT [m]>\n```\n\n\n:::\n:::\n\n\n# 3. Data Wrangling\n\n## 3.1 Removal of Redundant Columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define columns to be removed\ncolumns_to_remove <- c(\"block\",\"street_name\")\n\n# Remove columns only if they exist in the dataframe\nrental_sf <- rental_sf %>%\n  dplyr::select(-all_of(columns_to_remove[columns_to_remove %in% names(rental_sf)]))\n```\n:::\n\n\n## 3.2 Calculate Number of Amenities Within 1km & Proximity To Nearest Amenity\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncalculate_amenities_and_proximity <- function(dataset1, dataset2, name_of_col_amenities, name_of_col_proximity, radius, calculateNumberOfAmenities) {\n  # Calculate distance matrix\n  dist_matrix <- st_distance(dataset1, dataset2) %>%\n    drop_units()\n  \n  if (calculateNumberOfAmenities){\n  # Calculate the number of amenities within the specified radius\n    dataset1[[name_of_col_amenities]] <- rowSums(dist_matrix <= radius)\n  }\n  # Calculate the proximity to the nearest amenity\n  dataset1[[name_of_col_proximity]] <- rowMins(dist_matrix)\n  \n  return(dataset1)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrental_sf <- \n  calculate_amenities_and_proximity(\n    rental_sf, kindergarten_sf, \"no_of_kindergarten_500m\", \"prox_kindergarten\", 500, TRUE\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., childcare_sf, \"no_of_childcare_500m\", \"prox_childcare\", 500, TRUE\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., hawker_sf, \"no_of_hawker_500m\", \"prox_hawker\", 500, TRUE\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., busstop_sf, \"no_of_busstop_500m\", \"prox_busstop\", 500, TRUE\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., shoppingmall_sf, \"no_of_shoppingmall_1km\", \"prox_shoppingmall\", 1000, TRUE\n  ) %>% \n  calculate_amenities_and_proximity(\n    ., mrt_sf, \"no_of_mrt_1km\", \"prox_mrt\", 1000, FALSE\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., primarysch_sf, \"no_of_pri_1km\", \"prox_prisch\", 1000, FALSE\n  )\n\n\n# Writing to RDS\nwrite_rds(rental_sf,'data/rds/rental_sf.rds')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- read_rds('data/rds/rental_sf.rds')\nhead(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 16 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 15786.61 ymin: 30769.77 xmax: 39668.39 ymax: 45634.94\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 17\n  rent_approval_date town       flat_type monthly_rent            geometry\n  <date>             <chr>      <chr>            <dbl>         <POINT [m]>\n1 2024-01-01         YISHUN     4-ROOM            3700 (29463.95 45634.94)\n2 2024-01-01         JURONG WE… 4-ROOM            3900 (15786.61 34389.18)\n3 2024-01-01         SENGKANG   5-ROOM            3700  (33244.8 42043.31)\n4 2024-01-01         KALLANG/W… 3-ROOM            3600 (30102.41 32911.75)\n5 2024-01-01         BEDOK      5-ROOM            4350 (39668.39 33918.01)\n6 2024-01-01         QUEENSTOWN 4-ROOM            3000 (25265.85 30769.77)\n# ℹ 12 more variables: no_of_kindergarten_500m <dbl>, prox_kindergarten <dbl>,\n#   no_of_childcare_500m <dbl>, prox_childcare <dbl>, no_of_hawker_500m <dbl>,\n#   prox_hawker <dbl>, no_of_busstop_500m <dbl>, prox_busstop <dbl>,\n#   no_of_shoppingmall_1km <dbl>, prox_shoppingmall <dbl>, prox_mrt <dbl>,\n#   prox_prisch <dbl>\n```\n\n\n:::\n:::\n\n\n## 3.3 Filter By Flat Type\n\nLet us get an overview of the distributions of the housing types. As shown in the histogram, we can see that there is significantly less data for flat types like 1-room, 2-room, and executive housing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- rental_sf %>%\n  group_by(flat_type) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = flat_type, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Flat Type\",\n       x = \"Flat Type\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\nHence, we will focus on analyzing the 3-room, 4-room, and 5-room flats since they show a more substantial presence in the dataset compared to smaller flat types.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- rental_sf %>% filter (flat_type == '3-ROOM' | flat_type == '4-ROOM' |flat_type == '5-ROOM' )\n```\n:::\n\n\n# 4. Overview Of Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"rent_approval_date\"      \"town\"                   \n [3] \"flat_type\"               \"monthly_rent\"           \n [5] \"geometry\"                \"no_of_kindergarten_500m\"\n [7] \"prox_kindergarten\"       \"no_of_childcare_500m\"   \n [9] \"prox_childcare\"          \"no_of_hawker_500m\"      \n[11] \"prox_hawker\"             \"no_of_busstop_500m\"     \n[13] \"prox_busstop\"            \"no_of_shoppingmall_1km\" \n[15] \"prox_shoppingmall\"       \"prox_mrt\"               \n[17] \"prox_prisch\"            \n```\n\n\n:::\n:::\n\n\n**Explanatory Variables:**\n\nContinuous\n\n-   Remaining Lease: `remaining_lease_total_months`\n\n-   Size of flat: `floor_area_sqft`\n\n-   Distance to transport: `distance_to_mrt_meters`\n\n-   Distance to amenities: `distance_to_pri_school_meters`\n\n-   Distance to central business district: `distance_to_cbd`\n\n-   Housing Type: `housing_type`\n\n-   Prox_to:\n\n-   \n\nCategorical\n\n-   Remaining Lease: `remaining_lease_range`\n\n-   Storey Height: `storey_range`\n\n**Dependent Variables:**\n\n-   rental Price: `rental_price`, `price_per_sqft`\n\n# 3. Shiny Storyboard (EDA)\n\n## 3.1 Distribution\n\n## 3.2\n\n# 4. Distribution\n\n## 4.1 Categorical Variables\n\n### 4.1.1 Housing Type\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- rental_sf %>%\n  group_by(flat_type) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = flat_type, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Flat Type\",\n       x = \"Flat Type\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n# Bivariate Analysis\n\n# Correlation Matrix\n\n# Drafts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf_main <- st_union(mpsz_sf) %>%\n    st_cast(\"POLYGON\")\nmpsz_sf_main <- mpsz_sf_main[c(12)]\n\nmpsz_sf_owin <- as.owin(mpsz_sf_main)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpsz_sf_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf%>% filter(PLN_AREA_N == 'ANG MO KIO'))+\n  tm_polygons()+\ntm_shape(rental_sf %>% filter(planning_area_ura == 'ANG MO KIO'))+\n  tm_dots()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}