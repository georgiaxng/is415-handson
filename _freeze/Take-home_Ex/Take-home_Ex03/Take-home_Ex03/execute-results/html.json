{
  "hash": "c0f11d332c424787dbaaa30461278500",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take Home Exercise 3\"\nauthor: \"Georgia Ng\"\ndate: \"October 17, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n  cache: true\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Click to view the code\"\n    embed-resources: true\n---\n\n\n# 1. Overview\n\n## 1.1 Introduction\n\n## 1.2 My Responsibilities\n\n-   Data Preparation, Preprocessing\n\n## 1.3 Importing Packages\n\nHere, we have loaded the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse, RColorBrewer, ggplot2, spatstat, jsonlite, units, matrixStats, httr)\n```\n:::\n\n\n# 2. The Data\n\nFor this project, we will be using the following data sets.\n\n-   Singapore Rental Flat Prices (Jan-17 to Sep-24) from data.gov.sg\n\n-   Master Plan 2014 Subzone Boundary (Web) from data.gov.sg\n\n-   Hawker Centres Dataset from [data.gov.sg](https://data.gov.sg/datasets?formats=GEOJSON%7CKML%7CSHP%7CKMZ&sort=relevancy&page=1&resultId=d_4a086da0a5553be1d89383cd90d07ecd)\n\n-   Kindergarten, Childcare, Primary School Datasets from [OneMap API](https://www.onemap.gov.sg/apidocs/)\n\n-   Bus Stops Location, MRT/ LRT Locations from [LTA Data Mall](https://datamall.lta.gov.sg/content/datamall/en/search_datasets.html)\n\n-   Shopping Malls Coordinates through wikipedia and webscraping with the coordinates retrieved through OneMap API\n\n## 2.1 Importing Geospatial Data\n\n### 2.1.1 Importing Singapore Subzone Boundaries\n\nThe code chunk below is used to import *MP_SUBZONE_WEB_PL* shapefile by using `st_read()` of **sf**packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_read(dsn = \"data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP/\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(mpsz_sf, 'data/rds/mpsz_sf.rds')\n```\n:::\n\n\nUsing `st_crs`, we can check the coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n```\n\n\n:::\n:::\n\n\n#### 2.1.1.1 Checking Validity of Geometries\n\nUsing st_is_valid, we can check to see whether all the polygons are valid or not. From the results, we can see a total of 9 not valid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# checks for the number of geometries that are invalid\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\nTo rectify this, we can use `st_make_valid()` to correct these invalid geometries as demonstrated in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_make_valid(mpsz_sf)\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### 2.1.2 Importing Kindergartens\n\nThis chunk of code imports the kindergartens data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkindergarten_json <- fromJSON(\"data/geospatial/kindergartens.json\")\n\nkindergarten_cleaned <- kindergarten_json$SrchResults[-1, ]\n\nkindergarten_df <- data.frame(\n  NAME = kindergarten_cleaned$NAME,\n  latitude = sapply(kindergarten_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[1])),\n  longitude = sapply(kindergarten_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[2]))\n)\n\nkindergarten_sf <- kindergarten_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\n### 2.1.3 Importing Childcare\n\nThis chunk of code imports the childcare data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchildcare_json <- fromJSON(\"data/geospatial/childcare.json\")\n\nchildcare_cleaned <- childcare_json$SrchResults[-1, ]\n\nchildcare_df <- data.frame(\n  NAME = childcare_cleaned$NAME,\n  latitude = sapply(childcare_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[1])),\n  longitude = sapply(childcare_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[2]))\n)\n\nchildcare_sf <- childcare_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\n### 2.1.4 Importing Hawker Centre\n\nSimilarly here, we will use `st_read` to read the geojson information, however since the columns values are in the format of html code of '\n\n<th>\n\n<td>\n\n' etc we will need to use a function to apply a regex expression in order to extract the name of the hawker centres.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhawker_sf <- st_read('data/geospatial/HawkerCentresGEOJSON.geojson')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `HawkerCentresGEOJSON' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/HawkerCentresGEOJSON.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 125 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6974 ymin: 1.272716 xmax: 103.9882 ymax: 1.449017\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\n# Function to extract name from description\nextract_name <- function(description) {\n  if (!is.na(description)) {\n    # Use regular expression to extract the NAME \n    name <- sub(\".*<th>NAME</th> <td>(.*?)</td>.*\", \"\\\\1\", description)\n    if (name == description) {\n      return(NA)  # Return NA if no match is found\n    }\n    return(name)\n  } else {\n    return(NA) \n  }\n}\n\n# Apply the extraction function to every row\nhawker_sf <- hawker_sf %>%\n  mutate(Name = sapply(Description, extract_name)) %>% select (-Description)\n```\n:::\n\n\nHere, we can see that the hawker centres are now appropriately named.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.7798 ymin: 1.284425 xmax: 103.9048 ymax: 1.449017\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n                             Name                      geometry\n1     Market Street Hawker Centre POINT Z (103.8502 1.284425 0)\n2    Marsiling Mall Hawker Centre POINT Z (103.7798 1.433539 0)\n3    Margaret Drive Hawker Centre POINT Z (103.8047 1.297486 0)\n4 Fernvale Hawker Centre & Market POINT Z (103.8771 1.391592 0)\n5       One Punggol Hawker Centre  POINT Z (103.9048 1.40819 0)\n6    Bukit Canberra Hawker Centre POINT Z (103.8225 1.449017 0)\n```\n\n\n:::\n:::\n\n\nAs shown above, we can see that the geographic coordinate system for the hawker dataset is in WGS84 and has XYZ coordinates, among which contains the Z-coordinates we do not need. Thus, we can use `st_zm()` to remove the Z-coordinate and project it to the SVY21 coordiate system using `st_transform()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhawker_sf <- st_zm(hawker_sf) %>%\n  st_transform(crs = 3414)\n\nhead(hawker_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 22042.51 ymin: 29650.7 xmax: 35955.52 ymax: 47850.43\nProjected CRS: SVY21 / Singapore TM\n                             Name                  geometry\n1     Market Street Hawker Centre  POINT (29874.82 29650.7)\n2    Marsiling Mall Hawker Centre POINT (22042.51 46139.03)\n3    Margaret Drive Hawker Centre  POINT (24816.7 31094.91)\n4 Fernvale Hawker Centre & Market  POINT (32867.9 41500.77)\n5       One Punggol Hawker Centre POINT (35955.52 43336.13)\n6    Bukit Canberra Hawker Centre POINT (26794.39 47850.43)\n```\n\n\n:::\n:::\n\n\n### 2.1.5 Importing Bus Stops\n\nHere we are importing the bus stop locations using `st_read` and also converting it to the SVY21 coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbusstop_sf <- st_read(dsn = \"data/geospatial/BusStopLocation_Jul2024/\", layer = \"BusStop\")%>%\n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `BusStop' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/BusStopLocation_Jul2024' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5166 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48285.52 ymax: 52983.82\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n### 2.1.6 Importing Shopping Malls\n\nHere we are importing the shopping mall locations using `read_csv` and also converting it to the SVY21 coordinate system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshoppingmall_sf <- read_csv('data/geospatial/shopping_mall_coordinates.csv') %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\n### 2.1.7 Importing MRT\n\nHere we are importing the mrt locations using `st_read`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmrt_sf <- st_read(dsn = \"data/geospatial/TrainStation_Jul2024/\", layer = \"RapidTransitSystemStation\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `RapidTransitSystemStation' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/TrainStation_Jul2024' \n  using driver `ESRI Shapefile'\nSimple feature collection with 230 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 6068.209 ymin: 27478.44 xmax: 45377.5 ymax: 47913.58\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\nHaving imported the dataset, we will now need to check for both invalid geometries and NA values before proceeding. The chunk of code below detects not only these but also resolves it. The final printed result shows that all geometries are now valid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check for invalid geometries and NA values\nvalidity_checks <- st_is_valid(mrt_sf, reason = TRUE)\n\n# Identify indices with NA\nna_indices <- which(is.na(validity_checks))\n\n# Filter out rows with NA values from the mrt object\nmrt_sf <- mrt_sf[-na_indices, ]\n\n# Verify the mrt object no longer contains invalid geometries\nany(is.na(sf::st_is_valid(mrt_sf)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nHere we use `st_transform()` to convert it to the SVY21 Coordinates System of CRS code 3414.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmrt_sf <- mrt_sf %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\n### 2.1.8 Importing Primary School\n\nThis chunk of code imports the primary school dataset from data.gov.sg and uses the `select()` function to select the relevant columns through the input of the column numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprimarysch_df = read_csv('data/geospatial/Generalinformationofschools.csv') %>% filter(mainlevel_code =='PRIMARY') %>% select(1,3,4)\n```\n:::\n\n\n#### 2.1.8.1 Geocoding Primary School Data using OneMap API\n\nSince this dataset only has the addresses and not the actual coordinates, we will need to use the OneMapAPI to geocode these addresses. This chunk of code contains a function whereby the OneMapApi is called upon and returns the actual latitude and longitude of the addresses inputted.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ngeocode <- function(address, postal) {\n  base_url <- \"https://www.onemap.gov.sg/api/common/elastic/search\"\n  query <- list(\"searchVal\" = address,\n                \"postal\" = postal,\n                \"returnGeom\" = \"Y\",\n                \"getAddrDetails\" = \"N\",\n                \"pageNum\" = \"1\")\n  \n  res <- GET(base_url, query = query)\n  restext<-content(res, as=\"text\")\n  \n  output <- fromJSON(restext)  %>% \n    as.data.frame %>%\n    select(results.LATITUDE, results.LONGITUDE)\n\n  return(output)\n}\n```\n:::\n\n\nThis chunk of code creates two columns for latitude and longitude and sets the default values to 0. Then it loops through every single row of the primary school dataset and calls upon the above function to populate the respective latitude and longitude values for each row.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nprimarysch_df$LATITUDE <- 0\nprimarysch_df$LONGITUDE <- 0\n\nfor (i in 1:nrow(primarysch_df)){\n  temp_output <- geocode(primarysch_df[i, 2], primarysch_df[i, 3])\n  print(i)\n  \n  primarysch_df$LATITUDE[i] <- temp_output$results.LATITUDE\n  primarysch_df$LONGITUDE[i] <- temp_output$results.LONGITUDE\n}\nwrite_rds(primarysch_df, 'data/rds/geocoded_primarysch.rds')\n```\n:::\n\n\nAs shown below, using `head()` we can see that the new columns for lat and long has been added with the values fetched using the OneMap API.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(primarysch_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 178\nColumns: 3\n$ school_name <chr> \"ADMIRALTY PRIMARY SCHOOL\", \"AHMAD IBRAHIM PRIMARY SCHOOL\"…\n$ address     <chr> \"11   WOODLANDS CIRCLE\", \"10   YISHUN STREET 11\", \"100  Br…\n$ postal_code <dbl> 738907, 768643, 579646, 159016, 544969, 569785, 569920, 22…\n```\n\n\n:::\n:::\n\n\nUsing `read_rds`, we can access the already processed and geocoded data from rds without needing to run through the geocoding function again. Since the data is in the WGS coordinate system, we can use `st_transform()` to project it to the `SVY21` coordinate system we will be using.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprimarysch_df <- read_rds('data/rds/geocoded_primarysch.rds')\nprimarysch_sf <- primarysch_df %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\n### 2.1.9 Inferring CBD\n\nFinally, let us factor in the proximity to the Central Business District - in the Downtown Core. For this, let us take the coordinates of Downtown Core to be the coordinates of the CBD:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlat <- 1.287953\nlng <- 103.851784\n\ncbd_sf <- data.frame(lat, lng) %>%\n  st_as_sf(coords = c(\"lng\", \"lat\"), crs=4326) %>%\n  st_transform(crs=3414)\n```\n:::\n\n\n## 2.2 Importing Aspatial Data\n\n### 2.2.1 Importing Rental Flat\n\nThe code chunk below is used to import the rental data from data.gov.sg.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df = read_csv('data/aspatial/RentingOutofFlats2024CSV.csv')\n```\n:::\n\n\nTo get a brief overview of existing columns of this dataset, we can use `colnames()` to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(rental_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rent_approval_date\" \"town\"               \"block\"             \n[4] \"street_name\"        \"flat_type\"          \"monthly_rent\"      \n```\n\n\n:::\n:::\n\n\n#### 2.2.1.1 Converting `rent_approval_date` to a Valid Date Format\n\nSince the `rent_approval_date` is in the chr format, we will want to convert it to the date format so that we can later better access and use this variable. This is done so by the `ym()` as shown in the chunk of code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df$rent_approval_date <- ym(rental_df$rent_approval_date)\n```\n:::\n\n\n#### 2.2.1.2 Filtering For 2024\n\nSince the dataset is rather large, we want to size down our scope and instead focus on only the 2024 data, which in this case is from Jan 2024 to Sep 2024.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df <- rental_df %>%\n  filter(year(rent_approval_date) == 2024)\n```\n:::\n\n\n#### 2.2.1.3 Geocoding Rental Flat Data Using OneMap API\n\nLike the primary school data, we face the similar problem here thus we will need to go through the geocoding process similarly to what we have done above. The geocoding function:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ngeocode <- function(block, streetname) {\n  base_url <- \"https://www.onemap.gov.sg/api/common/elastic/search\"\n  address <- paste(block, streetname, sep = \" \")\n  query <- list(\"searchVal\" = address, \n                \"returnGeom\" = \"Y\",\n                \"getAddrDetails\" = \"N\",\n                \"pageNum\" = \"1\")\n  \n  res <- GET(base_url, query = query)\n  restext<-content(res, as=\"text\")\n  \n  output <- fromJSON(restext)  %>% \n    as.data.frame %>%\n    select(results.LATITUDE, results.LONGITUDE)\n\n  return(output)\n}\n```\n:::\n\n\nThis chunk of code then calls upon the above function for every single row of the `rental_df` and writes it to the rds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df$LATITUDE <- 0\nrental_df$LONGITUDE <- 0\n\nfor (i in 1:nrow(rental_df)){\n  temp_output <- geocode(rental_df[i, 3], rental_df[i, 4])\n  print(i)\n  \n  rental_df$LATITUDE[i] <- temp_output$results.LATITUDE\n  rental_df$LONGITUDE[i] <- temp_output$results.LONGITUDE\n}\nwrite_rds(rental_df, 'data/rds/geocoded_rental_2024.rds')\n```\n:::\n\n\nWithout needing to run the above time-consuming method yet again, we can just read the data from the rds here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_df <- read_rds('data/rds/geocoded_rental_2024.rds')\n```\n:::\n\n\n#### 2.2.1.4 CRS Adjustments\n\nAnother important step after importing the dataset is checking the coordinate system used, as seen in the result below using `st_crs()`, we can see that there is no CRS stated for `rental_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(rental_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System: NA\n```\n\n\n:::\n:::\n\n\nTherefore, we need to convert the longitude and latitude columns into a spatial format. Since our dataset is based in Singapore and it uses the SVY21 coordinate reference system (CRS Code: 3414), we will use the `st_transform()` function to perform the conversion and create the geometry column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- rental_df %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\nUsing `st_crs()`, we can check and verify that the conversion is successful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 15786.61 ymin: 30769.77 xmax: 39668.39 ymax: 45634.94\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 7\n  rent_approval_date town            block street_name    flat_type monthly_rent\n  <date>             <chr>           <chr> <chr>          <chr>            <dbl>\n1 2024-01-01         YISHUN          386   YISHUN RING RD 4-ROOM            3700\n2 2024-01-01         JURONG WEST     140B  CORPORATION DR 4-ROOM            3900\n3 2024-01-01         SENGKANG        471B  FERNVALE ST    5-ROOM            3700\n4 2024-01-01         KALLANG/WHAMPOA 10    GLOUCESTER RD  3-ROOM            3600\n5 2024-01-01         BEDOK           31    BEDOK STH AVE… 5-ROOM            4350\n6 2024-01-01         QUEENSTOWN      82    STRATHMORE AVE 4-ROOM            3000\n# ℹ 1 more variable: geometry <POINT [m]>\n```\n\n\n:::\n:::\n\n\n#### 2.2.1.5 Checking for NA values\n\nThis chunk of code checks the dataset for any na values in all of the columns. As shown below, there is none.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf %>%\n  summarise(across(everything(), ~ sum(is.na(.)))) -> extra_NA \nextra_NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 6 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 11519.15 ymin: 28097.64 xmax: 45192.3 ymax: 48741.06\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 1 × 7\n  rent_approval_date  town block street_name flat_type monthly_rent\n               <int> <int> <int>       <int>     <int>        <int>\n1                  0     0     0           0         0            0\n# ℹ 1 more variable: geometry <MULTIPOINT [m]>\n```\n\n\n:::\n:::\n\n\n# 3. Data Wrangling\n\n## 3.1 Removal of Redundant Columns\n\nTo increase efficiency and reduce the data size, we can remove columns we do not need like the `block` and `street_name` in which we have already utilised previously and now have no use for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define columns to be removed\ncolumns_to_remove <- c(\"block\",\"street_name\")\n\n# Remove columns only if they exist in the dataframe\nrental_sf <- rental_sf %>%\n  dplyr::select(-all_of(columns_to_remove[columns_to_remove %in% names(rental_sf)]))\n```\n:::\n\n\n## 3.2 Filter By Flat Type\n\nLet us get an overview of the distributions of the housing types. As shown in the histogram, we can see that there is significantly less data for flat types like 1-room, 2-room, and executive housing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- rental_sf %>%\n  group_by(flat_type) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = flat_type, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Flat Type\",\n       x = \"Flat Type\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\nHence, we will focus on analyzing the 3-room, 4-room, and 5-room flats since they show a more substantial presence in the dataset compared to smaller flat types.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- rental_sf %>% filter (flat_type == '3-ROOM' | flat_type == '4-ROOM' |flat_type == '5-ROOM' )\n```\n:::\n\n\n## 3.3 Adding Region to Rental Data\n\nThis chunk of code performs a left join with `mpsz_sf`to categorise the different flats into different regions in order to better understand the rental trends.\n\n### 3.3.1 Left Joining with `mpsz_sf`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform the left join by dropping the geometry from 'datab' and only bringing in 'region_n'\nrental_sf <- rental_sf %>%\n  left_join(st_drop_geometry(mpsz_sf) %>% select(PLN_AREA_N, REGION_N) %>% distinct(PLN_AREA_N, .keep_all = TRUE), \n            by = c(\"town\" = \"PLN_AREA_N\"))\n```\n:::\n\n\n### 3.3.2 Identifying Rows with NA values\n\nThen, let's perform a check to see if any of the rows have na values in the newly created column and display it. As shown here we can see that there are multiple rows in which the `town` column was unable to find a matching value in the `mpsz_sf` `PLN_AREA_N` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf_with_na <- rental_sf %>%\n  filter(is.na(REGION_N))\n\nrental_sf_with_na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1471 features and 5 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 19536.43 ymin: 28634.73 xmax: 33665.81 ymax: 41493.47\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 1,471 × 6\n   rent_approval_date town      flat_type monthly_rent            geometry\n * <date>             <chr>     <chr>            <dbl>         <POINT [m]>\n 1 2024-01-01         KALLANG/… 3-ROOM            3600 (30102.41 32911.75)\n 2 2024-01-01         KALLANG/… 3-ROOM            2300 (19536.43 41493.47)\n 3 2024-01-01         CENTRAL   3-ROOM            3000 (29435.92 29669.46)\n 4 2024-01-01         KALLANG/… 3-ROOM            1850 (19536.43 41493.47)\n 5 2024-01-01         KALLANG/… 4-ROOM            3400 (31184.91 34078.85)\n 6 2024-01-01         KALLANG/… 5-ROOM            4100  (31013.62 33175.3)\n 7 2024-01-01         KALLANG/… 3-ROOM            3200 (31618.57 33708.83)\n 8 2024-01-01         KALLANG/… 3-ROOM            2400 (31228.06 33432.22)\n 9 2024-01-01         CENTRAL   3-ROOM            2850 (29067.24 29360.52)\n10 2024-01-01         KALLANG/… 3-ROOM            2700 (31547.37 31835.93)\n# ℹ 1,461 more rows\n# ℹ 1 more variable: REGION_N <chr>\n```\n\n\n:::\n:::\n\n\nUsing unique, we can identify the `town` values of these problematic rows and also the available regions in `mpsz_sf` so that we have a brief idea of what are the possible values we can later use. In particular, the problematic values are 'Kallang/Whampoa' and 'Central'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique (rental_sf_with_na$town)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"KALLANG/WHAMPOA\" \"CENTRAL\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nunique(mpsz_sf$REGION_N)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"CENTRAL REGION\"    \"WEST REGION\"       \"EAST REGION\"      \n[4] \"NORTH-EAST REGION\" \"NORTH REGION\"     \n```\n\n\n:::\n:::\n\n\nSince the value is Kallang/Whampoa, let's try to find the region of either Kallang or Whampoa through the filter()\\` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- mpsz_sf%>% filter(PLN_AREA_N == 'KALLANG' | PLN_AREA_N == 'WHAMPOA') %>% select(PLN_AREA_N,REGION_N)\ntest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 9 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 29224.85 ymin: 30694.74 xmax: 33809.38 ymax: 34738.73\nProjected CRS: SVY21\n  PLN_AREA_N       REGION_N                       geometry\n1    KALLANG CENTRAL REGION POLYGON ((31632.98 30741.73...\n2    KALLANG CENTRAL REGION POLYGON ((31915.99 31851.24...\n3    KALLANG CENTRAL REGION POLYGON ((31494.25 32088.46...\n4    KALLANG CENTRAL REGION POLYGON ((32710.73 33608.07...\n5    KALLANG CENTRAL REGION POLYGON ((31277.37 34723.29...\n6    KALLANG CENTRAL REGION POLYGON ((31389.56 32098.17...\n7    KALLANG CENTRAL REGION POLYGON ((30344.12 32879.39...\n8    KALLANG CENTRAL REGION POLYGON ((32160.87 32549.12...\n9    KALLANG CENTRAL REGION POLYGON ((31437.02 32345.27...\n```\n\n\n:::\n:::\n\n\nWhile we can't find a match for Whampoa, we can see that Kallang falls under the Central Region. From the naming, we can also make the deduction that the town 'Central' likely falls under the same region. Thus by using a `if_else` statement we can assign the region Central Region to these towns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- rental_sf %>%\n  mutate(REGION_N = if_else(town == 'CENTRAL' | town == 'KALLANG/WHAMPOA', 'CENTRAL REGION', REGION_N))\n```\n:::\n\n\nLet us also rename the column to standardise the namings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- rental_sf %>% rename(region = REGION_N)\n```\n:::\n\n\n## 3.4 Calculate Number of Facilities Within A Certain Distance & Proximity To Nearest Facility\n\nSince the number of facilities within range and proximity to certain facilities are some of the most important factors of rental prices, it is important for us to include that in our analysis as well. Thus to do so we have the below function to made these calculations based on the locations of the different facilities' datasets we have imported compared with the individual rental flats themselves.\n\n::: callout-note\nNote: the calculateNumberOffacilities is a parameter used to indicate if the calculation of facilities for a particular facility is required.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncalculate_facilities_and_proximity <- function(dataset1, dataset2, name_of_col_facilities, name_of_col_proximity, radius, calculateNumberOfFacilities) {\n  # Calculate distance matrix\n  dist_matrix <- st_distance(dataset1, dataset2) %>%\n    drop_units()\n  \n  if (calculateNumberOfFacilities){\n  # Calculate the number of facilities within the specified radius\n    dataset1[[name_of_col_facilities]] <- rowSums(dist_matrix <= radius)\n  }\n  # Calculate the proximity to the nearest facility\n  dataset1[[name_of_col_proximity]] <- rowMins(dist_matrix)\n  \n  return(dataset1)\n}\n```\n:::\n\n\nThe below chunk of code calls upon the `calculate_facilities_and_proximity()` based on the different parameters stated for each facility. We indicated for the mrt and primary school to not be included in the calculations for the count within a certain radius as the distance to such facilities has way more importance than the actual count of it which is usually one within a certain range since these facilities are more spread out.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrental_sf <- \n  calculate_facilities_and_proximity(\n    rental_sf, kindergarten_sf, \"no_of_kindergarten_500m\", \"prox_kindergarten\", 500, TRUE\n  ) %>%\n  calculate_facilities_and_proximity(\n    ., childcare_sf, \"no_of_childcare_500m\", \"prox_childcare\", 500, TRUE\n  ) %>%\n  calculate_facilities_and_proximity(\n    ., hawker_sf, \"no_of_hawker_500m\", \"prox_hawker\", 500, TRUE\n  ) %>%\n  calculate_facilities_and_proximity(\n    ., busstop_sf, \"no_of_busstop_500m\", \"prox_busstop\", 500, TRUE\n  ) %>%\n  calculate_facilities_and_proximity(\n    ., shoppingmall_sf, \"no_of_shoppingmall_1km\", \"prox_shoppingmall\", 1000, TRUE\n  ) %>% \n  calculate_facilities_and_proximity(\n    ., mrt_sf, \"x\", \"prox_mrt\", 1000, FALSE\n  ) %>%\n  calculate_facilities_and_proximity(\n    ., primarysch_sf, \"x\", \"prox_prisch\", 1000, FALSE\n  ) %>%\n  calculate_facilities_and_proximity(\n    ., cbd_sf, \"x\", \"prox_cbd\", 1000, FALSE\n  )\n\n\n# Writing to RDS\nwrite_rds(rental_sf,'data/rds/rental_sf.rds')\n```\n:::\n\n\nLikewise, to skip the whole time-consuming process, we can instead read the rds data using the below code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrental_sf <- read_rds('data/rds/rental_sf.rds')\nglimpse(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 25,713\nColumns: 19\n$ rent_approval_date      <date> 2024-01-01, 2024-01-01, 2024-01-01, 2024-01-0…\n$ town                    <chr> \"YISHUN\", \"JURONG WEST\", \"SENGKANG\", \"KALLANG/…\n$ flat_type               <chr> \"4-ROOM\", \"4-ROOM\", \"5-ROOM\", \"3-ROOM\", \"5-ROO…\n$ monthly_rent            <dbl> 3700, 3900, 3700, 3600, 4350, 3000, 3800, 3600…\n$ geometry                <POINT [m]> POINT (29463.95 45634.94), POINT (15786.…\n$ region                  <chr> \"NORTH REGION\", \"WEST REGION\", \"NORTH-EAST REG…\n$ no_of_kindergarten_500m <dbl> 1, 1, 0, 1, 1, 6, 3, 1, 1, 1, 1, 0, 2, 4, 0, 0…\n$ prox_kindergarten       <dbl> 3.717727e+02, 1.241314e+02, 6.531547e+02, 4.47…\n$ no_of_childcare_500m    <dbl> 10, 9, 4, 3, 6, 11, 9, 9, 7, 6, 4, 1, 8, 10, 2…\n$ prox_childcare          <dbl> 6.318731e+01, 7.642944e+01, 8.264710e+01, 4.47…\n$ no_of_hawker_500m       <dbl> 1, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0…\n$ prox_hawker             <dbl> 478.4537, 840.4254, 660.6058, 332.1417, 354.77…\n$ no_of_busstop_500m      <dbl> 17, 17, 6, 11, 13, 17, 15, 8, 16, 11, 5, 6, 17…\n$ prox_busstop            <dbl> 174.00119, 80.37739, 70.48567, 161.93848, 280.…\n$ no_of_shoppingmall_1km  <dbl> 1, 1, 1, 2, 0, 3, 1, 2, 1, 2, 1, 0, 3, 4, 0, 1…\n$ prox_shoppingmall       <dbl> 704.70468, 905.82230, 735.18898, 565.82028, 10…\n$ prox_mrt                <dbl> 1259.97262, 1869.01210, 197.18773, 175.98753, …\n$ prox_prisch             <dbl> 271.15943, 1353.83517, 86.23193, 234.73109, 57…\n$ prox_cbd                <dbl> 15605.314, 14916.316, 12419.101, 2871.311, 103…\n```\n\n\n:::\n:::\n\n\n# 4. Overview Of Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(rental_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"rent_approval_date\"      \"town\"                   \n [3] \"flat_type\"               \"monthly_rent\"           \n [5] \"geometry\"                \"region\"                 \n [7] \"no_of_kindergarten_500m\" \"prox_kindergarten\"      \n [9] \"no_of_childcare_500m\"    \"prox_childcare\"         \n[11] \"no_of_hawker_500m\"       \"prox_hawker\"            \n[13] \"no_of_busstop_500m\"      \"prox_busstop\"           \n[15] \"no_of_shoppingmall_1km\"  \"prox_shoppingmall\"      \n[17] \"prox_mrt\"                \"prox_prisch\"            \n[19] \"prox_cbd\"               \n```\n\n\n:::\n:::\n\n\n**Dependent Variables:**\n\n-   Monthly Rental: `monthly_rent`\n\n**Explanatory Variables:**\n\nContinuous\n\n-   Prox\\_ \\[distance to closest\\]: kindergarten, childcare, hawker, bus stops, shopping mall, mrt, primary schools, cbd\n\n-   Count of xx within xx distance: `no_of_kindergarten_500m`, `no_of_childcare_500m`, `no_of_hawker_500m`, `no_of_busstop_500m`, `no_of_shoppingmall_1km`\n\nCategorical\n\n-   Flat Type: `flat_type`\n\n-   Town: `town`\n\n-   Region: `region`\n\n# 3. Shiny Storyboard (EDA)\n\n## 3.1 Distribution\n\n## 3.2\n\n# 4. Distribution\n\n## 4.1 Categorical Variables\n\n### 4.1.1 Housing Type\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- rental_sf %>%\n  group_by(flat_type) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = flat_type, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Flat Type\",\n       x = \"Flat Type\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n\n\n# Bivariate Analysis\n\n# Correlation Matrix\n\n# Drafts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf_main <- st_union(mpsz_sf) %>%\n    st_cast(\"POLYGON\")\nmpsz_sf_main <- mpsz_sf_main[c(12)]\n\nmpsz_sf_owin <- as.owin(mpsz_sf_main)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpsz_sf_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf%>% filter(PLN_AREA_N == 'ANG MO KIO'))+\n  tm_polygons()+\ntm_shape(rental_sf %>% filter(planning_area_ura == 'ANG MO KIO'))+\n  tm_dots()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}