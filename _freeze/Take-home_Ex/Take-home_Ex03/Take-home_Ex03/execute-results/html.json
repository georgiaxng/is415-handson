{
  "hash": "a24829dabf4c618c480050053b2774ee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take Home Exercise 3\"\nauthor: \"Georgia Ng\"\ndate: \"October 17, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n  cache: true\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Click to view the code\"\n    embed-resources: true\n---\n\n\n# 1. Overview\n\n## 1.1 Introduction\n\n## 1.2 My Responsibilities\n\n-   Data Preparation, Preprocessing\n\n## 1.3 Importing Packages\n\nHere, we have loaded the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse, RColorBrewer, ggplot2, spatstat, jsonlite, units, matrixStats, httr)\n```\n:::\n\n\n# 2. The Data\n\nFor this project, we will be using the following data sets.\n\n-   Singapore Resale Flat Prices (Jan-17 to Sep-24) from [Kaggle](https://www.kaggle.com/datasets/lzytim/hdb-resale-prices?select=resale_hdb_price_for_kaggle_2024-30sep.csv), an accumulation of information relating to the sale of Singapore's public housing apartments colloquially referred to as flats\n\n    -   This dataset augments the original dataset by including 4 important categories of information:\n\n        1.  X/Y lat/lng coordinates, which can be used for geospatial plotting.\n\n        2.  Information about the closest MRT station to the flat\n\n        3.  Information about the closest primary school to flat\n\n        4.  the URA planning area (or town) of the flat.\n\n-   Master Plan 2014 Subzone Boundary (Web) from data.gov.sg\n\n-   HDB Property Info from [data.gov.sg](https://data.gov.sg/collections/150/view)\n\n-   Hawker Centres Dataset from [data.gov.sg](https://data.gov.sg/datasets?formats=GEOJSON%7CKML%7CSHP%7CKMZ&sort=relevancy&page=1&resultId=d_4a086da0a5553be1d89383cd90d07ecd)\n\n-   Kindergarten, Childcare datasets from [OneMap API](https://www.onemap.gov.sg/apidocs/)\n\n-   Bus Stops Location from [LTA Data Mall](https://datamall.lta.gov.sg/content/datamall/en/search_datasets.html?searchText=bus%20stop)\n\n-   Shopping Mall Coordinates from [Kaggle](https://www.kaggle.com/datasets/karthikgangula/shopping-mall-coordinates?resource=download)\n\n## 2.1 Importing Geospatial Data\n\n### 2.1.1 Importing Singapore Subzone Boundaries\n\nThe code chunk below is used to import *MP_SUBZONE_WEB_PL* shapefile by using `st_read()` of **sf**packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_read(dsn = \"data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP/\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n\n```{.r .cell-code}\nwrite_rds(mpsz_sf, 'data/rds/mpsz_sf.rds')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n```\n\n\n:::\n:::\n\n\n#### 2.1.1.1 Checking Validity of Geometries\n\nUsing st_is_valid, we can check to see whether all the polygons are valid or not. From the results, we can see a total of 9 not valid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# checks for the number of geometries that are invalid\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n:::\n\n\nTo rectify this, we can use `st_make_valid()` to correct these invalid geometries as demonstrated in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_make_valid(mpsz_sf)\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nHere is a plot of Singapore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpsz_sf)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### 2.1.2 Importing Kindergartens\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nkindergarten_json <- fromJSON(\"data/geospatial/kindergartens.json\")\n\nkindergarten_cleaned <- kindergarten_json$SrchResults[-1, ]\n\nkindergarten_df <- data.frame(\n  NAME = kindergarten_cleaned$NAME,\n  latitude = sapply(kindergarten_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[1])),\n  longitude = sapply(kindergarten_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[2]))\n)\n\nkindergarten_sf <- kindergarten_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf) +\n  tm_polygons()+\n  tm_shape(kindergarten_sf) +\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### 2.1.3 Importing Childcare\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nchildcare_json <- fromJSON(\"data/geospatial/childcare.json\")\n\nchildcare_cleaned <- childcare_json$SrchResults[-1, ]\n\nchildcare_df <- data.frame(\n  NAME = childcare_cleaned$NAME,\n  latitude = sapply(childcare_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[1])),\n  longitude = sapply(childcare_cleaned$LatLng, function(x) as.numeric(unlist(strsplit(x, \",\"))[2]))\n)\n\nchildcare_sf <- childcare_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf) +\n  tm_polygons()+\n  tm_shape(childcare_sf) +\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### 2.1.4 Importing Hawker Centre\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhawker_sf <- st_read('data/geospatial/HawkerCentresGEOJSON.geojson')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `HawkerCentresGEOJSON' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/HawkerCentresGEOJSON.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 125 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6974 ymin: 1.272716 xmax: 103.9882 ymax: 1.449017\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\n# Function to extract name from description\nextract_name <- function(description) {\n  if (!is.na(description)) {\n    # Use regular expression to extract the NAME \n    name <- sub(\".*<th>NAME</th> <td>(.*?)</td>.*\", \"\\\\1\", description)\n    if (name == description) {\n      return(NA)  # Return NA if no match is found\n    }\n    return(name)\n  } else {\n    return(NA) \n  }\n}\n\n# Apply the extraction function to every row\nhawker_sf <- hawker_sf %>%\n  mutate(Name = sapply(Description, extract_name)) %>% select (-Description)\n\n# Verify the results\nglimpse(hawker_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 125\nColumns: 2\n$ Name     <chr> \"Market Street Hawker Centre\", \"Marsiling Mall Hawker Centre\"…\n$ geometry <POINT [°]> POINT Z (103.8502 1.284425 0), POINT Z (103.7798 1.4335…\n```\n\n\n:::\n:::\n\n\nAs shown above, we can see that the geographic coordinate system for the hawker dataset is in WGS84 and has XYZ coordinates, among which contains the Z-coordinates we do not need. Thus, we can use `st_zm()` to remove the Z-coordinate and project it to the SVY21 coordiate system using `st_transform()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhawker_sf <- st_zm(hawker_sf) %>%\n  st_transform(crs = 3414)\n\nhead(hawker_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 22042.51 ymin: 29650.7 xmax: 35955.52 ymax: 47850.43\nProjected CRS: SVY21 / Singapore TM\n                             Name                  geometry\n1     Market Street Hawker Centre  POINT (29874.82 29650.7)\n2    Marsiling Mall Hawker Centre POINT (22042.51 46139.03)\n3    Margaret Drive Hawker Centre  POINT (24816.7 31094.91)\n4 Fernvale Hawker Centre & Market  POINT (32867.9 41500.77)\n5       One Punggol Hawker Centre POINT (35955.52 43336.13)\n6    Bukit Canberra Hawker Centre POINT (26794.39 47850.43)\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf) +\n  tm_polygons()+\n  tm_shape(hawker_sf) +\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n### 2.1.5 Importing Bus Stops\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbusstop_sf <- st_read(dsn = \"data/geospatial/BusStopLocation_Jul2024/\", layer = \"BusStop\")%>%\n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `BusStop' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Take-home_Ex/Take-home_Ex03/data/geospatial/BusStopLocation_Jul2024' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5166 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48285.52 ymax: 52983.82\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n### 2.1.6 Importing Shopping Malls\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshoppingmall_sf <- read_csv('data/geospatial/shopping_mall_coordinates.csv') %>%\n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\n## 2.2 Importing Aspatial Data\n\n### 2.2.1 Importing Resale Flat Prices\n\nThe code chunk below is used to import the Resale Flat Prices dataset from Kaggle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_df = read_csv('data/aspatial/resale_hdb_price_for_kaggle_2024-30sep.csv')\n```\n:::\n\n\nTo get a brief overview of existing columns of this dataset, we can use `colnames()` to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(resale_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"...1\"                          \"month\"                        \n [3] \"storey_range\"                  \"floor_area_sqm\"               \n [5] \"flat_model\"                    \"lease_commence_date\"          \n [7] \"remaining_lease\"               \"resale_price\"                 \n [9] \"floor_area_sqft\"               \"price_per_sqft\"               \n[11] \"blk_no\"                        \"road_name\"                    \n[13] \"building\"                      \"postal\"                       \n[15] \"address\"                       \"lease_commence_date_r\"        \n[17] \"planning_area_ura\"             \"region_ura\"                   \n[19] \"x\"                             \"y\"                            \n[21] \"latitude\"                      \"longitude\"                    \n[23] \"closest_mrt_station\"           \"distance_to_mrt_meters\"       \n[25] \"transport_type\"                \"line_color\"                   \n[27] \"distance_to_cbd\"               \"closest_pri_school\"           \n[29] \"distance_to_pri_school_meters\"\n```\n\n\n:::\n:::\n\n\n#### 2.2.1.1 CRS Adjustments\n\nAnother important step after importing the dataset is checking the coordinate system used, as seen in the result below using `st_crs()`, we can see that there is no CRS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(resale_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System: NA\n```\n\n\n:::\n:::\n\n\nTherefore, we need to convert the longitude and latitude columns into a spatial format. Since our dataset is based in Singapore and it uses the SVY21 coordinate reference system (CRS Code: 3414), we will use the `st_transform()` function to perform the conversion and create the geometry column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- resale_df %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs=4326) %>%\n  st_transform(crs = 3414)\n```\n:::\n\n\nUsing `st_crs()`, we can check and verify that the conversion is successful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(resale_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(resale_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 29\n   ...1 month      storey_range floor_area_sqm flat_model    lease_commence_date\n  <dbl> <date>     <chr>                 <dbl> <chr>         <date>             \n1     0 2017-01-01 10 TO 12                 44 Improved      1979-01-01         \n2     1 2017-01-01 01 TO 03                 67 New Generati… 1978-01-01         \n3     2 2017-01-01 01 TO 03                 67 New Generati… 1980-01-01         \n4     3 2017-01-01 04 TO 06                 68 New Generati… 1980-01-01         \n5     4 2017-01-01 01 TO 03                 67 New Generati… 1980-01-01         \n6     5 2017-01-01 01 TO 03                 68 New Generati… 1981-01-01         \n# ℹ 23 more variables: remaining_lease <chr>, resale_price <dbl>,\n#   floor_area_sqft <dbl>, price_per_sqft <dbl>, blk_no <chr>, road_name <chr>,\n#   building <chr>, postal <chr>, address <chr>, lease_commence_date_r <date>,\n#   planning_area_ura <chr>, region_ura <chr>, x <dbl>, y <dbl>,\n#   latitude <dbl>, longitude <dbl>, closest_mrt_station <chr>,\n#   distance_to_mrt_meters <dbl>, transport_type <chr>, line_color <chr>,\n#   distance_to_cbd <dbl>, closest_pri_school <chr>, …\n```\n\n\n:::\n:::\n\n\n#### 2.2.1.2 Checking for NA values\n\nThis chunk of code checks the dataset for any na values in all of the columns. As shown below, there is none.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf %>%\n  summarise(across(everything(), ~ sum(is.na(.)))) -> extra_NA \nextra_NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 27 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 11519.15 ymin: 28097.64 xmax: 45192.3 ymax: 48741.06\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 1 × 28\n   ...1 month storey_range floor_area_sqm flat_model lease_commence_date\n  <int> <int>        <int>          <int>      <int>               <int>\n1     0     0            0              0          0                   0\n# ℹ 22 more variables: remaining_lease <int>, resale_price <int>,\n#   floor_area_sqft <int>, price_per_sqft <int>, blk_no <int>, road_name <int>,\n#   building <int>, postal <int>, address <int>, lease_commence_date_r <int>,\n#   planning_area_ura <int>, region_ura <int>, x <int>, y <int>,\n#   closest_mrt_station <int>, distance_to_mrt_meters <int>,\n#   transport_type <int>, line_color <int>, distance_to_cbd <int>,\n#   closest_pri_school <int>, distance_to_pri_school_meters <int>, …\n```\n\n\n:::\n:::\n\n\n#### 2.2.1.3 Time Period Selection\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- resale_sf %>% filter (year(month) == 2024)\n```\n:::\n\n\n### 2.2.2 Importing HDB Property Information\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhdb_info_df <- read_csv('data/aspatial/HDB Property Information.csv')\n```\n:::\n\n\n# 3. Data Wrangling\n\n## 3.1 Adding Housing Type for Flats\n\nTo assess whether the housing type influences the resale price of flats, we need to include this variable in our analysis. However, the current dataset lacks this information and thus we will be deriving it using other relevant variables. Specifically, we can use the floor area of the flats to determine the housing type, based on the guidelines provided on [data.gov.sg](https://www.data.com.sg/template-m.jsp?p=my/1.html).\n\n-   2 Rm (2 room HDB Flat). 1 bedroom with a built-in area of about 45 sq m or 485 sq ft.\n\n-   3 Rm (3 room HDB Flat). 2 bedrooms with a built-in area of about 70 sq m or 754 sq ft.\n\n-   4 Rm (4 room HDB Flat). 3 bedrooms with a built-in area of about 90 sq m or 969 sq ft.\n\n-   5 Rm (5 room HDB Flat). 3 bedrooms with a built-in area of about 110 sq m or 1,184 sq ft.\n\n-   EA (Executive Apartment). 3/4 bedrooms with built-in area of about 150 sqm or 1,615 sqft.\n\n-   EM (Executive Mansionette). Same as Executive apartment, except it has two levels.\n\n-   6 Rm (6 room HDB Flat). Jumbo flat joint by two 3 room flats\n\nParticularly, we will just group EA, EM and 6 rm flats into one category since there is no way for us right now to differentiate just by the size of the flats.\n\nThis chunk of code below derives the housing type for each flat by using conditional statements to check if the stated floor area is closer to that of a particular housing type and add the value in the new column created using `mutate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- resale_sf %>%\n  mutate(housing_type = case_when(\n    floor_area_sqft <= 619 ~ 2,  # Closer to 485 sqft\n    floor_area_sqft > 619 & floor_area_sqft <= 862 ~ 3,  # Closer to 754 sqft\n    floor_area_sqft > 862 & floor_area_sqft <= 1076 ~ 4,  # Closer to 969 sqft\n    floor_area_sqft > 1076 & floor_area_sqft <= 1399 ~ 5,  # Closer to 1184 sqft\n    floor_area_sqft > 1399 ~ 6,  # Closer to 1615 sqft, EA/EM/6 Rm\n  ))\n```\n:::\n\n\n## 3.2 Remaining Lease\n\n### 3.2.1 Grouping Remaining Lease By Range\n\nFirst, let us convert the lease period from `chr` to total months. Below, we extract the different year and month from the string and then make the calculations to convert it to total months.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to convert lease period to total months\nconvert_to_months <- function(lease) {\n  parts <- strsplit(lease, \" \")[[1]]  # Split by space\n  years <- as.numeric(parts[1])        # Extract years\n  # Check if months are present\n  if (length(parts) > 2) {\n    months <- as.numeric(parts[3])       # Extract months if present\n  } else {\n    months <- 0                           # Set months to 0 if not present\n  }\n  \n  total_months <- years * 12 + months  # Convert to total months\n  return(total_months)\n}\nresale_sf <- resale_sf %>%\n  mutate(remaining_lease_total_months = sapply(remaining_lease, convert_to_months))\n```\n:::\n\n\nUsing the number of total months, we can then get a brief overview of the remaining lease of the resale flat including the mins and max. In this case, we can see that the minimum number of months is 497 (ard 41 years) and maximum is 1173 (around 97 years). This information will later be useful in setting the ranges for the remaining lease.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(resale_sf['remaining_lease_total_months'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n remaining_lease_total_months          geometry     \n Min.   : 497.0               POINT        :126468  \n 1st Qu.: 746.0               epsg:3414    :     0  \n Median : 893.0               +proj=tmer...:     0  \n Mean   : 894.3                                     \n 3rd Qu.:1090.0                                     \n Max.   :1173.0                                     \n```\n\n\n:::\n:::\n\n\nSince the minimum is 41 years, our date range can start from 40-49 years onwards.\n\n::: callout-note\nE.g. 40-49 years refers to 40 years 0 months to 49 years 11 months.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the ranges and labels\nbreaks <- c(480, 600, 720, 840, 960, 1080, 1200)\nlabels <- c( \"40-49 years\", \"50-59 years\", \"60-69 years\", \"70-79 years\", \"80-89 years\", \"90-99 years\")\n\nresale_sf <- resale_sf %>%\n  mutate(remaining_lease_range = cut(remaining_lease_total_months, breaks = breaks, labels = labels))\n```\n:::\n\n\n### 3.2.2 Converting Remaining Lease to Year\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to convert lease period to total years\nconvert_to_years <- function(lease) {\n  parts <- strsplit(lease, \" \")[[1]]  \n  years <- as.numeric(parts[1])        \n  # Check if months are present\n  if (length(parts) > 2) {\n    months <- as.numeric(parts[3])      \n  } else {\n    months <- 0                          \n  }\n  \n  total_years <- years + (months / 12)  # Convert to total years\n  return(total_years)\n}\n\n# Apply the updated function\nresale_sf <- resale_sf %>%\n  mutate(remaining_lease_years = sapply(remaining_lease, convert_to_years))\n```\n:::\n\n\n## 3.3 Removal of Redundant Columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define columns to be removed\ncolumns_to_remove <- c(\"floor_area_sqm\", \"flat_model\", \"lease_commence_date\", \"remaining_lease\", \"blk_no\", \"road_name\", \"building\", \"address\", \"lease_commence_date_r\", \"postal\",\"...1\", \"x\", \"y\", \"transport_type\", \"line_color\")\n\n# Remove columns only if they exist in the dataframe\nresale_sf <- resale_sf %>%\n  dplyr::select(-all_of(columns_to_remove[columns_to_remove %in% names(resale_sf)]))\n```\n:::\n\n\n## 3.4 Storey Ranges\n\n### 3.4.1 Grouping of High Storeys\n\nThrough the histogram of the storey ranges, we can observe a right skewed distribution which shows that higher storeys are of a much lower frequency among resale flats. This is likely due to the fact that most HDB flats in Singapore are lower-rise buildings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- resale_sf %>%\n  group_by(storey_range) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = storey_range, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Storey Range\",\n       x = \"Storey Range\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-31-1.png){width=1152}\n:::\n:::\n\n\nHere is a summary of the maximum floor levels of all the HDB flats in Singapore. As shown here we can observe that both the mean and median maximum floor is a mere 12.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(hdb_info_df$max_floor_lvl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    1.0     6.0    12.0    12.1    16.0    50.0 \n```\n\n\n:::\n:::\n\n\nThus, to simplify our analysis and make the visualization easier to interpret, we can combine the higher storey ranges into a single broader range. In particular, we will group the floors 16 or higher together to form the 16+ floors range. As seen below, the results are 6 categories of storey ranges.\n\nNote: storey_range_grouped is duplicated twice so that one column can be used for the subsequent dummy coding of the storey ranges which will later be replaced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- resale_sf %>%\n    mutate(storey_range_grouped = case_when(\n        storey_range %in% c(\"01 TO 03\", \"04 TO 06\", \"07 TO 09\", \"10 TO 12\", \"13 TO 15\") ~ \n            gsub(\"^0*([0-9]+) TO 0*([0-9]+)$\", \"floor_\\\\1_to_\\\\2\", storey_range),  # Remove leading 0s\n        storey_range %in% c(\"16 TO 18\", \"19 TO 21\", \"22 TO 24\", \"25 TO 27\", \"28 TO 30\", \n                             \"31 TO 33\", \"34 TO 36\", \"37 TO 39\", \"40 TO 42\", \n                             \"43 TO 45\", \"46 TO 48\", \"49 TO 51\") ~ \"floor_16_and_above\",\n        TRUE ~ storey_range\n    )) %>%\n    mutate(storey_range_grouped_dummy = case_when(\n        storey_range %in% c(\"01 TO 03\", \"04 TO 06\", \"07 TO 09\", \"10 TO 12\", \"13 TO 15\") ~ \n            gsub(\"^0*([0-9]+) TO 0*([0-9]+)$\", \"floor_\\\\1_to_\\\\2\", storey_range),  # Remove leading 0s\n        storey_range %in% c(\"16 TO 18\", \"19 TO 21\", \"22 TO 24\", \"25 TO 27\", \"28 TO 30\", \n                             \"31 TO 33\", \"34 TO 36\", \"37 TO 39\", \"40 TO 42\", \n                             \"43 TO 45\", \"46 TO 48\", \"49 TO 51\") ~ \"floor_16_and_above\", # Change format for 16+\n        TRUE ~ storey_range\n    ))\n\n# Plot the grouped data\nggplot(resale_sf, aes(x = storey_range_grouped)) +\n    geom_bar() +\n    geom_text(stat='count', aes(label=..count..), vjust=-0.5) +\n    labs(title = \"Count of Storey Range (Grouped)\",\n         x = \"Storey Range\",\n         y = \"Count\") +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n### 3.4.2 Dummy Coding of Storey Ranges\n\nTo convert categorical variables into a numerical format that can be easily used in regression models, we can perform dummy coding which is basically statistical technique involving creating binary (0 or 1) variables for each category of a categorical variable, allowing the model to interpret and analyze categorical data.\n\nFor e.g. if a flat falls within the \"01 TO 03\" storey range, the corresponding dummy variable is coded as 1, and all others are coded as 0 (\\[1,0,0,0,0,0\\])\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- resale_sf %>%\n  pivot_wider(\n    names_from = storey_range_grouped_dummy, values_from = storey_range_grouped_dummy, \n              values_fn = list(storey_range_grouped_dummy = ~1), values_fill = 0,     \n) \n```\n:::\n\n\n## 3.5 Calculate Number of Amenities Within 1km & Proximity To Nearest Amenity\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_amenities_and_proximity <- function(dataset1, dataset2, name_of_col_amenities, name_of_col_proximity, radius) {\n  # Calculate distance matrix\n  dist_matrix <- st_distance(dataset1, dataset2) %>%\n    drop_units()\n  \n  # Calculate the number of amenities within the specified radius\n  dataset1[[name_of_col_amenities]] <- rowSums(dist_matrix <= radius)\n  \n  # Calculate the proximity to the nearest amenity\n  dataset1[[name_of_col_proximity]] <- rowMins(dist_matrix)\n  \n  return(dataset1)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- \n  calculate_amenities_and_proximity(\n    resale_sf, kindergarten_sf, \"no_of_kindergarten_500m\", \"prox_kindergarten\", 500\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., childcare_sf, \"no_of_childcare_500m\", \"prox_childcare\", 500\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., hawker_sf, \"no_of_hawker_500m\", \"prox_hawker\", 500\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., busstop_sf, \"no_of_busstop_500m\", \"prox_busstop\", 500\n  ) %>%\n  calculate_amenities_and_proximity(\n    ., shoppingmall_sf, \"no_of_shoppingmall_1km\", \"prox_shoppingmall\", 1000\n  )\n\n# Writing to RDS\nwrite_rds(resale_sf,'data/rds/resale_sf.rds')\n```\n:::\n\n\n# 4. Overview Of Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_sf <- read_rds('data/rds/resale_sf.rds')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(resale_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"month\"                         \"storey_range\"                 \n [3] \"resale_price\"                  \"floor_area_sqft\"              \n [5] \"price_per_sqft\"                \"planning_area_ura\"            \n [7] \"region_ura\"                    \"closest_mrt_station\"          \n [9] \"distance_to_mrt_meters\"        \"distance_to_cbd\"              \n[11] \"closest_pri_school\"            \"distance_to_pri_school_meters\"\n[13] \"geometry\"                      \"housing_type\"                 \n[15] \"remaining_lease_total_months\"  \"remaining_lease_range\"        \n[17] \"remaining_lease_years\"         \"storey_range_grouped\"         \n[19] \"04 TO 06\"                      \"16+\"                          \n[21] \"01 TO 03\"                      \"07 TO 09\"                     \n[23] \"10 TO 12\"                      \"13 TO 15\"                     \n[25] \"no_of_kindergarten_500m\"       \"prox_kindergarten\"            \n[27] \"no_of_childcare_500m\"          \"prox_childcare\"               \n[29] \"no_of_hawker_500m\"             \"prox_hawker\"                  \n[31] \"no_of_busstop_500m\"            \"prox_busstop\"                 \n[33] \"no_of_shoppingmall_1km\"        \"prox_shoppingmall\"            \n```\n\n\n:::\n:::\n\n\n**Explanatory Variables:**\n\nContinuous\n\n-   Remaining Lease: `remaining_lease_total_months`\n\n-   Size of flat: `floor_area_sqft`\n\n-   Distance to transport: `distance_to_mrt_meters`\n\n-   Distance to amenities: `distance_to_pri_school_meters`\n\n-   Distance to central business district: `distance_to_cbd`\n\n-   Housing Type: `housing_type`\n\n-   Prox_to:\n\n-   \n\nCategorical\n\n-   Remaining Lease: `remaining_lease_range`\n\n-   Storey Height: `storey_range`\n\n**Dependent Variables:**\n\n-   Resale Price: `resale_price`, `price_per_sqft`\n\n# 3. Shiny Storyboard (EDA)\n\n## 3.1 Distribution\n\n## 3.2\n\n# 4. Distribution\n\n## 4.1 Categorical Variables\n\n### 4.1.1 Remaining Lease Range\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- resale_sf %>%\n  group_by(remaining_lease_range) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = remaining_lease_range, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Remaining Lease Ranges\",\n       x = \"Remaining Lease Range\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n### 4.1.2 Storey Range\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- resale_sf %>%\n  group_by(storey_range_grouped) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = storey_range_grouped, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Storey Range\",\n       x = \"Storey Range\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-40-1.png){width=1152}\n:::\n:::\n\n\n### 4.1.3 Housing Type\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a summary of counts for each remaining lease range\ncount_data <- resale_sf %>%\n  group_by(housing_type) %>%\n  summarise(count = n())\n\n# Create the bar plot with labels\nggplot(count_data, aes(x = housing_type, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") + \n  geom_text(aes(label = count), vjust = -0.5, size = 4) +  # Add labels on top of the bars\n  labs(title = \"Count of Housing Type\",\n       x = \"Housing Type\",\n       y = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n# Bivariate Analysis\n\n# Correlation Matrix\n\n# Drafts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlease_storey_table <- table(resale_sf$storey_range_grouped, resale_sf$remaining_lease_range)\nlease_storey_df <- as.data.frame(lease_storey_table)\n\n# Heatmap with ggplot\nggplot(lease_storey_df, aes(Var1, Var2, fill = Freq)) +\n  geom_tile() +\n  scale_fill_gradient(low = \"white\", high = \"red\") +\n  labs(title = \"Heatmap: Storey Range vs. Remaining Lease Range\",\n       x = \"Storey Range\",\n       y = \"Remaining Lease Range\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-42-1.png){width=1152}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf_main <- st_union(mpsz_sf) %>%\n    st_cast(\"POLYGON\")\nmpsz_sf_main <- mpsz_sf_main[c(12)]\n\nmpsz_sf_owin <- as.owin(mpsz_sf_main)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpsz_sf_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_2020_sf <- resale_sf %>% filter (year(month) == 2020)\nresale_2021_sf <- resale_sf %>% filter (year(month) == 2021)\nresale_2022_sf <- resale_sf %>% filter (year(month) == 2022)\nresale_2023_sf <- resale_sf %>% filter (year(month) == 2023)\nresale_2024_sf <- resale_sf %>% filter (year(month) == 2024)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf%>% filter(PLN_AREA_N == 'ANG MO KIO'))+\n  tm_polygons()+\ntm_shape(resale_2023_sf %>% filter(planning_area_ura == 'ANG MO KIO'))+\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf%>% filter(PLN_AREA_N == 'ANG MO KIO'))+\n  tm_polygons()+\ntm_shape(resale_2024_sf %>% filter(planning_area_ura == 'ANG MO KIO'))+\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex03_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- resale_sf %>% filter(housing_type == 'EA/EM/6 Rm')\ntest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 0 features and 33 fields\nBounding box:  xmin: NA ymin: NA xmax: NA ymax: NA\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 0 × 34\n# ℹ 34 variables: month <date>, storey_range <chr>, resale_price <dbl>,\n#   floor_area_sqft <dbl>, price_per_sqft <dbl>, planning_area_ura <chr>,\n#   region_ura <chr>, closest_mrt_station <chr>, distance_to_mrt_meters <dbl>,\n#   distance_to_cbd <dbl>, closest_pri_school <chr>,\n#   distance_to_pri_school_meters <dbl>, geometry <GEOMETRY [m]>,\n#   housing_type <dbl>, remaining_lease_total_months <dbl>,\n#   remaining_lease_range <fct>, remaining_lease_years <dbl>, …\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}