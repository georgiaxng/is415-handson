{
  "hash": "cc67e6622e883670cf5eb0b141f578b3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands On Exercise 4: Spatio-Temporal Point Patterns Analysis\"\nauthor: \"Georgia Ng\"\ndate: \"September 10, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n  cache: true\n---\n\n\n## 4.0 Overview\n\nA spatio-temporal point process (also called space-time or spatial-temporal point process) is a random collection of points, where each point represents the time and location of an event. Examples of events include incidence of disease, sightings or births of a species, or the occurrences of fires, earthquakes, lightning strikes, tsunamis, or volcanic eruptions. In this lesson, you will learn the basic concepts and methods of Spatio-temporal Point Patterns Analysis. You will also gain hands-on experience on using these methods to discover real-world point processes.\n\nThe specific questions we would like to answer are:\n\n-   are the locations of forest fire in Kepulauan Bangka Belitung spatial and spatio-temporally independent?\n\n-   if the answer is NO, where and when the observed forest fire locations tend to cluster?\n\n## 4.1 Importing the Packages\n\nFor the purpose of this study, five R packages will be used. They are:\n\n-   `rgdal` for importing geospatial data in GIS file format such as shapefile into R and save them as Spatial\\*DataFrame,\n\n-   `maptools` for converting Spatial\\* object into ppp object,\n\n-   `raster` for handling raster data in R,\n\n-   `sparr` provides functions to estimate fixed and adoptive kernel-smoothed spatial relative risk surfaces via the density-ratio method and perform subsequent inference. Fixed-bandwidth spatiotemporal density and relative risk estimation is also supported.\n\n-   `spatstat` for performing Spatial Point Patterns Analysis such as kcross, Lcross, etc., and\n\n-   `tmap` for producing cartographic quality thematic maps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, raster, spatstat, sparr, tmap, tidyverse)\n```\n:::\n\n\n## 4.2 The Data\n\nFor the purpose of this exercise, two data sets will be used, they are:\n\n-   *forestfires*, a csv file provides locations of forest fire detected from the Moderate Resolution Imaging Spectroradiometer (MODIS) sensor data. The data are downloaded from [Fire Information for Resource Management System](https://firms.modaps.eosdis.nasa.gov/download/). For the purpose of this exercise, only forest fires within Kepulauan Bangka Belitung will be used.\n\n-   *Kepulauan_Bangka_Belitung*, an ESRI shapefile showing the sub-district (i.e.Â [kelurahan](https://en.wikipedia.org/wiki/Villages_of_Indonesia)) boundary of Kepulauan Bangka Belitung. The data set was downloaded from [Indonesia Geospatial](https://www.indonesia-geospasial.com/2023/05/download-shapefile-batas-administrasi.html) portal. The original data covers the whole Indonesia. For the purpose of this exercise, only sub-districts within Kepulauan Bangka Belitung are extracted.\n\n### 4.2.1 Importing Study Area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkbb <- st_read(dsn=\"data/rawdata/\", \n                   layer=\"Kepulauan_Bangka_Belitung\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Kepulauan_Bangka_Belitung' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Hands-on_Ex/Hands-on_Ex04/data/rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 298 features and 27 fields\nGeometry type: POLYGON\nDimension:     XYZ\nBounding box:  xmin: 105.1085 ymin: -3.116593 xmax: 106.8488 ymax: -1.501603\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n::: callout-note\nNotice that uniquely the polygon in the geometry column when imported is of a **Polygon Z** type. This means that each polygon not only defines a 2D shape but also includes elevation data with a z-coordinate. This additional z-dimension allows for a more detailed representation of the polygon's geometry, incorporating vertical information such as elevation or depth.\n:::\n\nThe below revised code chunk serves to do the following:\n\n1.  Group the boundaries up\n2.  Drop the Z values\n3.  Transform the coordinate system\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkbb_sf <- st_read(dsn=\"data/rawdata/\", \n                   layer=\"Kepulauan_Bangka_Belitung\") %>%\n  st_union()%>%\n  st_zm(drop = TRUE, what = \"ZM\")%>%\n  st_transform(32748)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Kepulauan_Bangka_Belitung' from data source \n  `/Users/georgiaxng/georgiaxng/is415-handson/Hands-on_Ex/Hands-on_Ex04/data/rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 298 features and 27 fields\nGeometry type: POLYGON\nDimension:     XYZ\nBounding box:  xmin: 105.1085 ymin: -3.116593 xmax: 106.8488 ymax: -1.501603\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n### 4.2.2 Converting OWIN\n\nNext, as.owin() is used to convert kbb into an owin object, which is a spatial window or region of interest for point pattern analysis. Once converted to an `owin` object, we can use it with functions from spatial point pattern analysis packages, such as `spatstat`, to analyze point patterns within the defined boundary. It helps in setting up the spatial context for further analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkbb_owin <- as.owin(kbb_sf)\nkbb_owin\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nwindow: polygonal boundary\nenclosing rectangle: [512066.8, 705559.4] x [9655398, 9834006] units\n```\n\n\n:::\n:::\n\n\nNext, `class()` is used to confirm if the output is indeed an owin object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(kbb_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"owin\"\n```\n\n\n:::\n:::\n\n\n### 4.2.3 Importing and Preparing Forest Fire Data\n\nNext, we will import the forest fire data set into the R environment. The code reads forest fire data from a CSV file, converts it into an `sf` object using longitude and latitude coordinates, and then reprojects the spatial data from WGS84 to the UTM zone 48S coordinate system. This prepares the data for further spatial analysis in a projection appropriate for the region of interest.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_sf <- read_csv(\"data/rawdata/forestfires.csv\") %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"),\n           crs=4326)%>%\n  st_transform(crs = 32748)\n```\n:::\n\n\nBecause `ppp` object only accept numeric or character as mark. The code chunk below is used to convert data type of `acq_date` to numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_sf <- fire_sf %>%\n  mutate(DayofYear = yday(acq_date)) %>%\n  mutate(Month_num = month(acq_date)) %>%\n  mutate(Month_fac = month(acq_date, label= TRUE, abbr = FALSE))\n```\n:::\n\n\n## 4.3 Visualising The Fire Points\n\n### 4.3.1 Overall Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(kbb_sf)+\n  tm_polygons() +\ntm_shape(fire_sf) +\n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### 4.3.2 Visualising Geographic Distribution Of Forest Fires By Month\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(kbb_sf) +\n  tm_polygons()+\n  tm_shape(fire_sf)+\n  tm_dots(size= 0.1)+\n  tm_facets(by=\"Month_fac\", free.coords = FALSE, drop.units= TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## 4.4 Computing STKDE by Month\n\n### 4.4.1 Extracting forest fires by month\n\nThe code chunk below is used to remove the unwanted fields from `fire_sf` sf data.frame. This is because `as.ppp()` only need the mark field and geometry field from the input sf data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_month <- fire_sf %>% \n  select(Month_num)\n```\n:::\n\n\n### 4.4.2 Creating ppp\n\nThe code chunk below is used to derive a ppp object called fire_month from fire_month of data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_month_ppp <- as.ppp(fire_month)\nfire_month_ppp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern: 741 points\nmarks are numeric, of storage type  'double'\nwindow: rectangle = [521564.1, 695791] x [9658137, 9828767] units\n```\n\n\n:::\n:::\n\n\nThe code chunk below is used to check the output is in the correct object class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fire_month_ppp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  741 points\nAverage intensity 2.49258e-08 points per square unit\n\nCoordinates are given to 10 decimal places\n\nmarks are numeric, of type 'double'\nSummary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   8.000   9.000   8.579  10.000  12.000 \n\nWindow: rectangle = [521564.1, 695791] x [9658137, 9828767] units\n                    (174200 x 170600 units)\nWindow area = 29728200000 square units\n```\n\n\n:::\n:::\n\n\nNext, we will check if there are duplicated point events by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(fire_month_ppp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n### 4.4.3 Including Owin Object\n\nThe code chunk below is used to combine origin_am_ppp and am_owin objects into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_month_owin <- fire_month_ppp[kbb_owin]\nsummary(fire_month_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  741 points\nAverage intensity 6.424519e-08 points per square unit\n\nCoordinates are given to 10 decimal places\n\nmarks are numeric, of type 'double'\nSummary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   8.000   9.000   8.579  10.000  12.000 \n\nWindow: polygonal boundary\n2 separate polygons (no holes)\n           vertices        area relative.area\npolygon 1     47493 11533600000      1.00e+00\npolygon 2       256      306427      2.66e-05\nenclosing rectangle: [512066.8, 705559.4] x [9655398, 9834006] units\n                     (193500 x 178600 units)\nWindow area = 11533900000 square units\nFraction of frame area: 0.334\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fire_month_owin)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### 4.4.4 Computing Spatio-Temporal KDE\n\nNext, `spattemp.density()` of sparr package is used to compute the `STKDE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_kde <- spattemp.density(fire_month_owin)\nsummary(st_kde)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 15102.47 (spatial)\n  lambda = 0.0304 (temporal)\n\nNo. of observations\n  741 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [512066.8, 705559.4] x [9655398, 9834006]\n\nTemporal bound\n  [1, 12]\n\nEvaluation\n  128 x 128 x 12 trivariate lattice\n  Density range: [1.233458e-27, 8.202976e-10]\n```\n\n\n:::\n:::\n\n\n### 4.4.5 Plotting the spatio-temporal KDE object\n\nIn the code chunk below, `plot()` of R base is used to the KDE for between July 2023 - December 2023.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntims <- c(7,8,9,10,11,12)\npar(mfcol=c(2,3))\nfor(i in tims){ \n  plot(st_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=paste(\"KDE at month\",i))\n}\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex04_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## 4.5 Computing STKDE by Day of Year\n\nIn this section, you will learn how to computer the STKDE of forest fires by day of year.\n\n### 4.5.1 Creating ppp object\n\nIn the code chunk below, DayofYear field is included in the output ppp object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_yday_ppp <- fire_sf %>% \n  select(DayofYear) %>%\n  as.ppp()\n```\n:::\n\n\n### 4.5.2 Including Owin object\n\nNext, code chunk below is used to combine the ppp object and the owin object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_yday_owin <- fire_yday_ppp[kbb_owin]\nsummary(fire_yday_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  741 points\nAverage intensity 6.424519e-08 points per square unit\n\nCoordinates are given to 10 decimal places\n\nmarks are numeric, of type 'double'\nSummary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   10.0   213.0   258.0   245.9   287.0   352.0 \n\nWindow: polygonal boundary\n2 separate polygons (no holes)\n           vertices        area relative.area\npolygon 1     47493 11533600000      1.00e+00\npolygon 2       256      306427      2.66e-05\nenclosing rectangle: [512066.8, 705559.4] x [9655398, 9834006] units\n                     (193500 x 178600 units)\nWindow area = 11533900000 square units\nFraction of frame area: 0.334\n```\n\n\n:::\n:::\n\n\n## 4.5.3\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_yday <- spattemp.density(\n  fire_yday_owin)\nsummary(kde_yday)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 15102.47 (spatial)\n  lambda = 6.3198 (temporal)\n\nNo. of observations\n  741 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [512066.8, 705559.4] x [9655398, 9834006]\n\nTemporal bound\n  [10, 352]\n\nEvaluation\n  128 x 128 x 343 trivariate lattice\n  Density range: [3.959516e-27, 2.751287e-12]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(kde_yday)\n```\n:::\n\n\n## 4.6 Computing STKDE by Day of Year: Improved method\n\nOne of the nice function provides in sparr package is `BOOT.spattemp()`. It support bandwidth selection for standalone spatiotemporal density/intensity based on bootstrap estimation of the MISE, providing an isotropic scalar spatial bandwidth and a scalar temporal bandwidth.\n\nCode chunk below uses `BOOT.spattemp()` to determine both the spatial bandwidth and the scalar temporal bandwidth.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nBOOT.spattemp(fire_yday_owin) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitialising...Done.\nOptimising...\nh = 15102.47 \b; lambda = 16.84806 \nh = 16612.72 \b; lambda = 16.84806 \nh = 15102.47 \b; lambda = 1527.095 \nh = 15480.03 \b; lambda = 771.9715 \nh = 15668.81 \b; lambda = 394.4098 \nh = 15763.2 \b; lambda = 205.6289 \nh = 15810.4 \b; lambda = 111.2385 \nh = 15833.99 \b; lambda = 64.04328 \nh = 15845.79 \b; lambda = 40.44567 \nh = 15851.69 \b; lambda = 28.64687 \nh = 15863.49 \b; lambda = 5.049258 \nh = 15854.64 \b; lambda = 22.74746 \nh = 15860.54 \b; lambda = 10.94866 \nh = 15859.07 \b; lambda = 13.89836 \nh = 14348.82 \b; lambda = 13.89836 \nh = 13216.87 \b; lambda = 12.42351 \nh = 12460.27 \b; lambda = 15.37321 \nh = 10760.88 \b; lambda = 16.11064 \nh = 8875.282 \b; lambda = 11.68608 \nh = 10432.08 \b; lambda = 12.97658 \nh = 7976.084 \b; lambda = 16.66371 \nh = 9286.281 \b; lambda = 15.60366 \nh = 9615.08 \b; lambda = 18.73771 \nh = 9206.581 \b; lambda = 21.61828 \nh = 8140.483 \b; lambda = 18.23073 \nh = 8795.582 \b; lambda = 17.70071 \nh = 9124.381 \b; lambda = 20.83477 \nh = 9164.856 \b; lambda = 19.52699 \nh = 8345.358 \b; lambda = 18.48998 \nh = 9297.65 \b; lambda = 18.67578 \nh = 8928.375 \b; lambda = 16.8495 \nh = 9105.736 \b; lambda = 18.85762 \nDone.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         h     lambda \n9105.73611   18.85762 \n```\n\n\n:::\n:::\n\n\n### 4.6.1 Computing spatio-temporal KDE\n\nNow, the STKDE will be derived by using h and lambda values derive in previous step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkde_yday <- spattemp.density(\n  fire_yday_owin,\n  h = 9000,\n  lambda = 19)\nsummary(kde_yday)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 9000 (spatial)\n  lambda = 19 (temporal)\n\nNo. of observations\n  741 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [512066.8, 705559.4] x [9655398, 9834006]\n\nTemporal bound\n  [10, 352]\n\nEvaluation\n  128 x 128 x 343 trivariate lattice\n  Density range: [2.001642e-19, 2.445724e-12]\n```\n\n\n:::\n:::\n\n\n### 4.6.2 Plotting the output spatio-temporal KDE\n\nLast, `plot()` of **sparr** package is used to plot the output as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(kde_yday)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}